/*
 * kadai04
 * MCMC: Markov chain Monte Carlo
 * Metropolis-Hastings algorithm (M-H algorithm)
 * 540479c
 * Yamaguchi Ryutaro
 *
 */

/*
 * output file is "bimodal_distribution.pdf", is contained in the same zip file.
 * The histogram is generated by gnuplot 5.0, using commands below.
 * gnuplot> binwidth=0.1
 * gnuplot> bin(x,width)=width*floor(x/width)+width/2.0
 * gnuplot> plot [-5:5] 'mh_algorithm_output.txt' using (bin($1,binwidth)):(0.5) smooth freq with boxes title "bimodal distribution"
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define MIN(a, b) ((a) > (b) ? (b) : (a))


/* ----------- XORSHIFT RANDOM NUMBER GENERATOR ----------- */
#define MAX_XORSHIFT 4294967295

unsigned int xorshift(void)
{
    static unsigned int x = 1;
    static unsigned int y = 2;
    static unsigned int z = 3;
    static unsigned int w = 4;
    unsigned int t;
    t = x ^ (x << 11);
    x = y;
    y = z;
    z = w;
    return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));
}

int random_integer(int m)
{
    return xorshift() % m;
}

double random_double(void)
{
    return xorshift() * 1.0 / MAX_XORSHIFT;
}

double random_normal()
{
    return sqrt(-2*log(random_double())) * cos(2 * M_PI * random_double());
}
/* ----------- END OF XORSHIFT RANDOM NUMBER GENERATOR ----------- */


double random_normal_d(double mu, double sigma)
{
    return random_normal() * sigma + mu;
}

void contain_random_normal(double *source, int datanum)
{
    for (int i = 0; i < datanum; i++) {
        source[i] = random_normal();
    }
}

double P(double x)
{
    return 1.0 / 3.90514 * exp(-(pow(x, 4.0) / 4.0 -  pow(x, 2.0) / 2.0));
}

double acceptance_rate(double next, double prsnt)
{
    return MIN(1, P(next)/P(prsnt));
}

double sigma = 3.5;

double Q(double x) /* arbitrary probability density Q(y|x): Gaussian distribution centered by x */
{
    return random_normal_d(x, sigma);
}

/* metropolis
 *
 * This function has three step.
 * 1. generate next_candidate based on a probability distribution Q(x).
 * 2. based on the acceptance_rate, accept next_candidate.
 *    if accepted, next_candidate is contained in target array.
 * 3. repeat process
 *
 * return value: target array length
 */
int metropolis(double* source, double* target, int datanum)
{
    double z_k = source[0];
    double next_candidate;
    int j = 0;
    for (int i = 0; i < datanum; i++) {
        next_candidate = Q(z_k);
        if (acceptance_rate(next_candidate, z_k) >= random_double()) {
            z_k = next_candidate;
            target[j++] = next_candidate;
        }
    }
    return j;
}

int cmp(const double *, const double *);

/* filenames */
char data_source[] = "mh_algorithm_source.txt";
char data_output[] = "mh_algorithm_output.txt";
char data_log[] = "mh_algorithm.log";

enum {
    DATANUM = 100000,
};
int main(void)
{
//  FILE *sfp = NULL;
    FILE *ofp = NULL;
    FILE *lfp = NULL;
//  if ((sfp = fopen(data_source, "r")) == NULL) {
//      perror(data_source);
//      exit(1);
//  }
    if ((ofp = fopen(data_output, "w")) == NULL) {
        perror(data_output);
        exit(1);
    }
    if ((lfp = fopen(data_log, "w")) == NULL) {
        perror(data_log);
        exit(1);
    }

    double *source = (double*)malloc(sizeof(double) * DATANUM);
    double *target = (double*)malloc(sizeof(double) * DATANUM);
    int target_length;

    contain_random_normal(source, DATANUM);

    target_length = metropolis(source, target, DATANUM);

    for (int i = 0; i < target_length; i++) {
        fprintf(lfp, "%f\n", target[i]);
    }
    for (int i = 0; i < target_length; i = i + 10) {
        fprintf(ofp, "%f\n", target[i]);
    }
//  qsort(source, DATANUM, sizeof(double), (int (*)(const void *, const void *))cmp);

//  fclose(sfp);
    fclose(ofp);
    fclose(lfp);
    free(source);
    free(target);
    return 0;
}

int cmp(const double *p, const double *q)
{
    return (*p > *q) - (*p < *q);
}
